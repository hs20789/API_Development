# 05. 바로 사용할 수 있는 파이썬 SDK 만들기

데이터 사이언티스트가 좋아할 만한 API를 만들기 위해선느 API를 쉽게 호출할 수 있도록 돕는 SDK를 제공해야 한다.
SDK는 많은 API 제공자가 제공하지 않지만, 사용자들에게는 큰 도움이 된다.

---

# 목차

- [API 서버](#api-서버)
   - [API 서버가 하는 핵심 역할](#api-서버가-하는-핵심-역할흐름)
   - [SDK가 추가되면 생기는 흐름](#sdk가-추가되면-생기는-흐름)
- [SDK](#sdk)
   - [SDK 개발 언어 선택](#sdk-개발-언어-선택-전략)
   - [최소 기능 SDK부터 시작하는 이유](#최소-기능-sdkminimum-viavle-sdk부터-시작하기)
- [SDK 전문가의 조언](#sdk-전문가의-조언)
   - [전문가의 조언1](#전문가의-조언1-sdk를-쉽게-설치하도록-만들어야-한다)
   - [전문가의 조언2](#전문가의-조언2-일관되고-자연스러운-파이썬-스타일의-sdk를-만들어야-한다)
- [SDK를 만들기 위한 사전 지식](#sdk를-만들기-위한-사전-지식)
   - [1. 용어들 설명](#1-기초-설명용어들-정리)
   - [2. 전체적인 흐름 설명](#2-전체적인-흐름-설명)
- [SDK 만들기](#sdk-만들기-실습)

---

## API 서버

API 서버는 클라이언트(브라우저·앱·다른 서버)가 네트워크로 요청한 기능을 규약(API 계약)에 맞게 처리해서 결과를 응답으로 돌려주는 백엔드 프로그램이다.
사용자는 화면에서 버튼을 누르지만, 실제로는 그 버튼이 API 서버에 요청을 보내고, API 서버가 일을 처리해 결과를 반환한다.

#### API 서버가 하는 핵심 역할(흐름)

요청 1건을 기준으로 API 서버는 보통 아래 순서로 움직인다.

1. 요청 수신

- HTTP/HTTPS(또는 gRPC) 요청을 받는다.
> 예: `GET /users/123`, `POST /orders`

2. 라우팅(어떤 기능을 실행할지 결정)

- URL 경로와 메서드(GET/POST 등)에 따라 어떤 핸들러(엔드포인트 함수)를 실행할지 결정한다.

3. 입력 검증 및 파싱

- 쿼리 파라미터, 경로 변수, JSON 바디가 형식/타입/필수 조건을 만족하는지 검사한다.
- FastAPI에서는 보통 Pydantic이 이 역할을 수행한다.

4. 인증/인가

- 누가 요청했는지(인증) 확인하고, 그 사용자가 이 작업을 할 권한이 있는지(인가)한다.
- FastAPI에서는 보통 Pydantic이 이 역할을 수행한다.

5. 비즈니스 로직 수행

- 서비스 규칙을 적용한다.
> 예: 재고가 부족하면 주문 거절, 이미 존재하는 이메일이면 가입 거절 등

6. 데이터 접근 및 변경

- 데이터베이스 CRUD
> 예: SQLAlchemy로 DB 조회 후 결과를 가져옴

7. 응답 생성

- 결과를 JSON 등으로 만들고, 적절한 HTTP 상태 코드와 함께 반환한다.
> 예: 200 OK, 201 Created, 400 Bad Request, 401 Unauthorized, 404 Not Found 등등

SDK가 없으면 클라이언트가 직접 HTTP를 구성해서 API 서버로 요청해야한다.(직접 API 호출)

`[사용자 앱 코드]  ──HTTP 직접 구성/전송──>  [API 서버]`

#### SDK가 추가되면 생기는 흐름

SDK가 생기면, 시스템의 기능이 추가되는 것이 아니라 클라이언트가 API 서버를 호출하는 방식이 바뀐다.

원래는 클라이언트가 직접 HTTP 요청을 만들던 일을 SDK가 대신 수행하고, 클라이언트는 **함수 호출**로 API를 사용하게 된다.

SDK가 없는 경우 (직접 호출)
클라이언트가 직접
- URL/경로 조합
- 헤더(인증 토큰) 붙이기
- JSON 바디 만들기
- 응답 JSON 파싱
- 에러 코드 해석
- 재시도/타임아웃/backoff 처리
등의 작업을 수행하고 서버로 요청해야한다.

SDK가 있는 경우(간접 호출) 클라이언트는 `client.create_user(...)` 같은 함수 호출만 하고, SDK가 내부에서 위의 작업을 수행해서 서버로 요청한다. 
즉, SDK가 클라이언트 내부에서 작업을 대리 수행하는 구조이다.

```
API 사용자(클라이언트 코드)
   ↓ (함수 호출)
SDK (클라이언트 라이브러리)
   ↓ (HTTP 요청)
데이터 전송 및 검증(Pydantic) → API 컨트롤러(FastAPI) → DB 클래스(SQLAlchemy) → DB(SQLite)
```

SDK에는 코드 예제나 디버거, 문서와 같은 다양한 요소가 포함될 수 있지만, 보통은 API를 쉽게 사용할 수 있게 해주는 맞춤형 소프트웨어 라이브러리를 의미한다. 이를 통해 개발자와 데이터 사이언티스트는 API 통신을 위해 추가적인 코드를 작성할 필요 없이 자신의 프로그래밍 언어에서 API를 직접 호출하고 상호 작용할 수 있다.

--- 

## SDK

1. SDK란 정확히 무엇인가?
SDK(Software Development Kit)는 특정 서비스/플랫폼의 기능을 개발자가 쉽게 활용하도록 제공되는 공식 개발 키트로, 보통 클라이언트 라이브러리(함수/클래스 형태), 인증·요청/응답 처리, 문서 및 예제를 포함한다. SDK는 REST API뿐 아니라 gRPC, GraphQL 등 다양한 인터페이스를 감쌀 수 있다.

2. 구체적인 예시
예를 들어, 프리미어 리그 SDK를 만든다고 생각해보자. 사용자는 SDK를 `import`한 뒤 API 키를 추가하면, 이후 모든 호출이 자동으로 인증된다. 
개발자는 이 SDK를 사용해 단일 함수 호출로 특정 날짜의 경기 일정이나 스코어보드를 쉽게 얻을 수 있다. SDK는 이런 복잡성을 줄여 주기 때문에 개발을 훨씬 빠르고 편하게 해준다.

잘 만들어지 SDK는 사용자가 마주하게 되는 복잡한 작업을 대신 처리해 준다. 몇 줄의 코드만 복사해 붙여 넣으면 데이터에 접근하고 조작할 수 있으며, 인증 방식(API 토큰을 이 함수에 넘기시오 등)도 명확히 안내해 준다.

**Python SDK 만들기**는 실무적으로 보면 패키지(배포 가능한 라이브러리) 만들기 위에 SDK 다운 설계/품질 요건을 추갛나 것이다. 
> 다만 모든 패키지가 SDK는 아니고, SDK는 패키지의 한 하위 범주라고 이해하는 편이 정확하다.

`관계 정리: 패키지 ⊃ 라이브러리 ⊃ SDK(대개)`

1. 패키지(package/distribution)
- `pip install ...`롤 설치 가능한 배포 단위이다.
- 구성 요소: 코드 + 메타데이터(pyproject.toml) + 의존성 + 버전 + (선택)리소스 파일
> 예: `numpy`, `requests`, `fastapi`

2. 라이브러리(Library)
- 재사용 가능한 코드 묶음이라는 개념적 범주이다.
- 파이썬에서는 대부분 라이브러리가 패키지 형태로 배포된다.

3. SDK(Software Development Kit)
- 특정 플랫폼/서비스/API를 개발자가 쉽게 쓰도록 하는 **도구 묶음**이다.
- Python에서는 거의 항상 패키지 형태로 배포되는 라이브러리로 구현된다.
- SDK는 보통 단순 라이브러리보다 범위가 넓다.
   - API 호출 래핑(클라이언트)
   - 인증 처리
   - 요청/응답 모델
   - 에러 타입/재시도/타임 아웃
   - 페이지네이션, 업로드/다운로드
   - 로컬/트레이싱 훅
   - 문서/예제/가이드

#### SDK 개발 언어 선택 전략

**SDK를 만들기 위해서는 먼저 대상 개발자가 누구인지, 그리고 그들이 AI를 어떻게 활용할지를 충분히 이해해야 한다.**

SDK를 개발할 때 가장 먼저 결정해야 할 사항은 지원할 프로그래밍 언어다. 중요한 점은 **SDK가 반드시 API가 작성된 언어와 같을 필요는 없다**는 것이다.
오히려 SDK는 API 소비자가 주로 사용하는 언어로 작성되어야 하며, 이들은 자신의 코드에서 SDK를 `import`해 API를 직접 호출하지않고, SDK를 통해 API와 상호작용하게 된다.

파이썬 SDK 개발을 시작할 때는 OAS로부터 파이썬용 클라이언트를 생성해 주는 오픈 소스 도구인 OpenAPI Python Client를 활용할 수 있다. 
이 도구는 기본적인 골격 코드를 생성해 주며, 여기에 기능을 추가해 나가는 방식으로 SDK를 점진적으로 완성할 수 있다.

그러나 지원하는 언어가 많아질수록 SDK의 유지 보수는 점점 더 복잡해진다. 이에 따라 Speakeasy, APIMatic, Fern 등의 상용 도구는 OAS를 기반으로 여러 언어의 SDK를 자동 생성하고 지속적으로 업데이트해주는 기능을 제공한다.

#### 최소 기능 SDK(minimum viavle SDK)부터 시작하기

먼저 SDK 프로젝트가 정상적으로 패키징되고 설치되는지를 확인하기 위해, 가장 기본적인 형태의 SDK부터 만들어 본다. 
이를 최소 기능 SDK(MVP)라고 한다.

초기에는 작동 여부만 확인할 수 있을 정도로 간단한 수준에서 시작하고, 그 이후, 필요한 기능을 단계적으로 추가한다.

SDK를 최소 기능부터 시작하는 이유는 한 문장으로 정리하면 초기 불확실성을 가장 싸게 줄이고, 운영 리스크를 통제하면서, 실제 사용 데이터를 기반으로 올바른 API/UX를 확정하기 위해서이다. SDK는 한 번 퍼지면 되돌리기 어렵고, 설계 실수가 장기 부재가 되기에 초기에는 작고 단단하게 가는 편이 비용 대비 효과가 크다.


1. SDK는 API 표면을 고정시키는 작업이다.

SDK가 제공하는 함수/클래스/타입은 사용자 코드에 직접 들어간다. 
즉, SDK의 고액 API는 곧 사용자 코드의 의존성이 된다.

- 초기에 너무 많이 공개하면, 나중에 API를 바꾸기 어렵고, 바꾸면 사용자 코드가 깨질 수도 있다.
- MVP로 최소 기능만 공개하면, 바꿔야 할 때 영향 범위가 작고, 호환성 관리가 쉬워진다.

2. 엔드포인트 래핑보다 기본기(신뢰성)이 더 중요하다.

SDK 품질을 결정하는 건 기능 수가 아니라 운영 품질이다.
MVP 접근은 기본기를 먼져 안정화한 뒤 기능을 늘린다.
반대로 모든 엔드포인트를 먼저 감싸기는 기능은 많지만, 운영에서 꺠지는 SDK가 되기 쉽다.

또한, 대부분의 SDK 사용자들은 일부 기능만 압도적으로 사용한다.
따라서 MVP로 Top 1~3 유스케이스만 빠르게 제공하면, 사용자는 SDK를 쓸 이유를 바로 얻고, 나머지 엔드포인트는 저수준 호출로 우회 제공해도 실사용에서는 충분한 경우가 많다.

---

## SDK 전문가의 조언

#### 전문가의 조언1: SDK를 쉽게 설치하도록 만들어야 한다.

많은 프로그래밍 언어에는 외부 저장소에서 라이브러리를 설치하는 표준 방식이 있다.
예를 들어, Node.js는 npm, 자바는 Maven을 사용하고, 파이썬은 PyPI를 표준 저장소로 사용한다. 파이썬 SDK 역시 PyPI에 배포할 수 있도록 구성하면, 앞에서 FastAPI나 SQLAlchemy 라이브러리를 설치했던 것처럼 개발자들은 pip 도구를 이용해 손쉽게 SDK를 설치할 수 있다.

컴퓨터 세상에서는 구조화된 데이터를 텍스트로 표현해 저장·전송·설정에 활용하기 위한 포맷이 있고, 대표적으로 JSON, TOML, YAML, XML 등이 있다. 
이들은 원리적으로 비슷한 구조(키-값, 리스트, 중첩)를 표현할 수 있지만 실무에서는 아무 포맷이나 쓰는 것이 안되는 경우가 많다.

왜냐하면 도구가 특정 파일명/포맷을 공식 입력으로 정의해두기 떄문이다.
즉, 어떤 형식이 주류가 되는 건 포맷의 우수성만이 아니라 생태계 표준화와 호환성의 결과이다.

현대 파이썬 패키징에서는 패키지 빌드/배포 설정과 메타데이터를 **pyproject.toml**에 모은다.

이 설정 파일은 pip과 같은 도구가 SDK를 올바르게 패키징하고 파이썬 환경에 설치할 수 있도록 도와준다.

#### 전문가의 조언2: 일관되고 자연스러운 파이썬 스타일의 SDK를 만들어야 한다.

SDK는 일관성과 예측 가능성을 갖춰야 한다. 함수 이름 짓기, 예외 처리 방식, 응답 형식 등은 SDK 전반에서 동일한 방식으로 유지돼야 사용자에게 혼란을 주지 않는다.
예를 들어, 단일 항목을 반환하는 함수는 `get_`으로 시작하고, 여러 항목을 반환하는 함수는 `list_`로 시작하는 것이다.

---

## SDK를 만들기 위한 사전 지식

#### 1. 기초 설명(용어들 정리)

- [프로젝트 루트](#프로젝트-루트): `pyproject.toml`이 있는 디렉토리
- [배포 이름(Distribution name)](#배포-이름): `pip install ...`에 쓰이는 이름
- [파이썬 패키지/모듈(Python Package/Module)](#파이썬-패키지모듈-이름): `import ...`에 쓰이는 이름
- [빌드 백엔드(Build Backend)](#빌드-백엔드): 소스에서 wheel/sdist를 만드는 도구 
- [`__init__.py`](#__init__py): 해당 디렉토리가 파이썬 패키지임을 알려주는 특별한 파일
- [`src/`레이아웃](#src-레이아웃): 배포/설치될 실제 파이썬 코드(패키지)를 프로젝트 루트가 아니라 `src/` 폴더 아래에 두는 구조를 말한다.
- [빌드 아키텍트](#배포-아티팩트): 소스 코드를 빌드 프로세스에 넣었을 때 생성되는 최종 결과물

### 프로젝트 루트(Project Root)

프로젝트 루트는 한 프로젝트의 최상위 기준 디렉토리로, 도구들이 프로젝트를 식별하고(어디부터가 한 프로젝트인지), 빌드·테스트·패키징·실행의 상대 경로 기준점으로 삼는 디렉토리이다.
파이썬 패키징/SDK 관점에서는 특히 **루트**의 정의가 실무에서 매우 중요하다.

1. 프로젝트 루트는 왜 필요한가?

실무 도구들은 이 폴더가 한 프로젝트의 루트다를 기준으로 다음을 결정한다.

- 빌드/패키징: 어떤 코드를 포함할지, 어떤 메타데이터를 적용할지
- 의존성 관리: `requirements.txt`, `poetry.lock`, `pyproject.toml` 읽기
- 테스트/린트: 테스트 디스커버리 시작 위치, 설정 파일 탐색
- 상대 경로: 설정 파일, 데이터 파일, 스크립트의 경로 기준

즉, 루트가 흔들리면 도구들이 서로 다른 기준으로 동작해 내 PC에선 되는데 CI에서 안되는 등의 문제가 생긴다.

2. 파이썬 패키징에서 프로젝트 루트는 어떻게 정해지는가?

> 가장 전형적인 기준: `pyproject.toml`이 있는 디렉토리

요즘 표준(PEP 517/518, PEP 621) 흐름에서는 `pyproject.toml`이 있는 디렉토리를 프로젝트 루트로 간주하는 것이 공식적인 약속이다.
`pip install .`에서 `.`은 현재 디렉토리(프로젝트 루트)를 의미한다.
`python -m build`도 현재 디렉토리의 `pyproject.toml`을 읽어 빌드한다. 

따라서, **SDK 프로젝트**를 만들 때는 보통 프로젝트 루트에 `pyproject.toml` 그 아래에 `src/`, `tests/`, `README.md` 등을 둔다.

3. 전형적인 프로젝트 루트 구조 예시

```
# 첫 번째 예시
my-sdk/                         # [프로젝트 루트] 모든 명령어(pip, pytest 등) 실행 위치
├── pyproject.toml              # 프로젝트의 심장: 빌드 도구, 의존성, 메타데이터 설정
├── README.md                   # 개발자를 위한 안내서 (설치법, 사용법)
├── LICENSE                     # 라이선스 (오픈소스라면 필수)
├── CHANGELOG.md                # 버전별 변경 사항 기록
├── src/                        # [Source Root] 실제 코드를 보호하는 격리 계층
│   └── my_sdk/                 # [메인 패키지] 사용자가 'import my_sdk'로 부를 이름
│       ├── __init__.py         # 패키지 선언 및 외부 노출 API 정의
│       ├── client.py           # SDK의 핵심: 메인 클라이언트 클래스 (예: MySDKClient)
│       ├── errors.py           # SDK 전용 예외 클래스들 (Exception) 정의
│       ├── _http.py            # 내부용: HTTP 통신 로직 (언더바(_)는 내부 전용임을 암시)
│       ├── resources/          # [하위 패키지] API 리소스별 분류 (도메인별 로직)
│       │   ├── __init__.py
│       │   └── users.py        # 예: sdk.users.get() 형태의 기능을 담당
│       └── models/             # [하위 패키지] 데이터 구조 및 타입 정의 (Pydantic 등)
│           ├── __init__.py
│           └── user.py         # User 데이터 객체(DTO) 정의
├── tests/                      # 테스트 코드 모음
│   └── test_client.py          # 주요 기능 정상 작동 확인용 테스트
├── examples/                   # 사용자를 위한 예제 코드 (SDK는 이게 아주 중요해요!)
│   └── quickstart.py           # 5분 만에 따라 하는 기본 사용법
├── docs/                       # 상세 문서 (Read the Docs 등을 위한 Sphinx/MkDocs)
└── .github/                    # GitHub 전용 설정
    └── workflows/              # CI/CD 설정: 푸시할 때마다 자동으로 테스트 실행
        └── test.yml

# 두 번째 예시
my_awesome_project/           <-- [프로젝트 루트] 모든 명령어는 여기서 실행!
├── .git/                     # Git 버전 관리 데이터
├── .venv/                    # 격리된 가상 환경 (로컬 개발용)
├── .github/                  # GitHub Actions (CI/CD) 설정
│   └── workflows/
│       └── test.yml
├── src/                      # [Source Root] 소스 코드 보호를 위한 폴더
│   └── my_app/               # [최상위 패키지] import my_app
│       ├── __init__.py       # "my_app은 패키지다"
│       ├── main.py           # 실행 메인 로직
│       ├── auth/             # [하위 패키지 1] import my_app.auth
│       │   ├── __init__.py   # "auth는 하위 패키지다"
│       │   └── login.py
│       └── database/         # [하위 패키지 2] import my_app.database
│           ├── __init__.py
│           └── connection.py
├── tests/                    # 테스트 코드 (루트에서 pytest 실행)
│   ├── __init__.py
│   ├── test_auth.py
│   └── test_db.py
├── pyproject.toml            # [핵심 설계도] 프로젝트 표준 설정
├── uv.lock (또는 poetry.lock)  # [확인서] 설치된 라이브러리 버전 고정
├── .gitignore                # Git 제외 목록 (venv, __pycache__ 등)
├── README.md                 # 프로젝트 설명서
└── LICENSE                   # 라이선스 정보
```

4. 프로젝트 루트 vs 패키지 루트 vs 모듈 위치 (호동 주의)


   1. 프로젝트 루트(Project root)
      - 레포의 최상위 기준 폴더
      - `pyproject.toml`이 위치하는 폴더

   2. 소스 루트(Source root) 또는 패키지 탐색 루트
      - `src/` 레이아웃을 쓰면 `src/`가 소스 루트가 된다.
      - 빌드 도구가 패키지를 찾는 기준 폴더

   3. 파이썬 패키지 디렉토리
      - `src/my_sdk/` 처럼 `__init__.py`를 가진 실제 패키지 폴더
      - `import my_sdk`의 대상

정리하면, `프로젝트 루트`는 프로젝트 전체의 기준이고 `src/`는 코드가 있는 기준, `src/my_sdk`는 import 단위(패키지)이다.

루트를 잘못 잡으면 `pip install .`를 다른 위치에서 실행해서 전혀 다른 프로젝트가 설치되고 설정 파일들이 정상적으로 적용되지 않으며, 상대 경로가 꼬여서 파일을 읽는 코드가 환경마다 깨지게된다. 또한, `src/` 레이아웃이 설정 없이 빌드 될 경우 패키지가 누락될 가능성도 있다.

### 배포 이름

배포 이름은 현대 파이썬 패키징에서는 보통 `pyproject.toml`의 `[project].name`으로 정한다.

1. 배포 이름이란 무엇인가?

배포 이름은 패키지 저장소(PyPI, 사내 레지스트리)에서 식별되는 설치 단위의 이름이다.

- 사용자는 이 이름으로 설치한다.
   - `pip install <배포이름>`
- 다른 프로젝트는 의존성으로 이 이름을 적는다.
   - `dependencies = ["<배포이름> >= 1.2.0"]`

> 즉, 배포 이름은 pip/의존성/레지스트리 관점의 이름이다.

2. 배포 이름 vs import 이름 (가장 중요한 구분)

배포 이름과 import 이름은 같을 수도 있고, 다를 수도 있으며, 같아야 할 의무가 없다.

- 배포 이름: `pip install ...`에 쓰는 이름
> `pyproject.toml`의 `[project].name`으로 정하며, 이것이 `pip install <name>`과 의존성 표기의 기준이 된다.

- import 이름(package/module name): `import ...`에 쓰는 이름(코드 폴더/모듈 파일 이름)
> `import` 이름은 `src/` 아래 패키지 디렉토리(예: `src/my_sdk/`)의 이름으로 결정되며, 배포 이름과 같을 수도 있고 다를 수도 있다.

예시
- `pip install scikit-learn`이지만 `import sklearn`
- `pip install pillow`이지만 `import PIL`
- `pip install pyyaml`이지만 `import yaml`

배포 이름은 하이픈(`-`) 사용이 허용되지만, import 이름은 파이썬 식별자 규칙 때문에 하이픈이 불가하다.



3. `pyproject.toml`이란 무엇인가

   - 역할: 프로젝트의 표준 메타데이터 + 빌드 설정의 중심
   현대 파이썬 패키징에서 `pyproject.toml`은 크게 두 축을 담당한다.

      - 빌드 시스템 정의: 이 프로젝트를 어떤 백엔드로 빌드할지
      - 프로젝트 메타데이터 정의: 이름, 버전, 의존성 등

   2. 가장 중요한 섹션 2개

      1. `[build-system]` (빌드 백엔드/빌드 의존성)
      여기서 setuptools/hatchiling/flit/pdm-backend 같은 빌드 백엔드를 지정한다.

      개념적으로는

      - 빌드할 떄 어떤 엔진을 쓸건지
      - 그 엔진을 쓰려면 무엇이 필요한지

      를 명시한다.

      2. `[project]` (프로젝트 메타데이터: 배포 이름 포함)

      여기가 **배포 이름**이 들어가는 곳이다.

         - `[project].name` = 배포 이름
         - `[project].version` = 버전
         - `[project].dependencies` = 런타임 의존성
         - `[project].requires-python` = 지원 파이썬 버전
         - (선택) `authors, description, readme, license` 등
      
      즉, 배포 이름은 `pyproject.toml`의 `[project].name`으로 정한다는 것이 현재 표준 흐름이다.

      3. `pyproject.toml`이 빌드/설치에서 어떻게 쓰이는가

         1. 로컬 설치
            - `pip install .`을 실행하면 pip은 현재 폴더의 `pyproject.toml`을 읽고 `[buile-system]`에 지정된 백엔드를 통해 빌드를 수행(필요시)하고, `[project]` 메타데이터를 가진 배포물로 설치한다.

         2. 배포(레지스트리 업로드)
            - `python -m build` 등을 실행하면 백엔드가 `wheel/sdist` 아티팩트를 만들고, 그 아티팩트의 메타데이터레 `[project].name`이 들어간다. 업로드하면 그 이름이 레지스트리의 **배포 이름**이 된다.

### 파이썬 패키지/모듈 이름

파이썬에서 패키지/모듈 이름은 `import` 문에서 사용하는 이름 체계를 말한다. 실무에서 혼동이 잦은 이유는 `pip install`에 쓰이는 배포 이름과는 별개이기 떄문이다.

1. 모듈(module) 이름이란

모듈은 보통 하나의 `.py` 파일이다.
모듈 이름은 그 파일명(확장자 제회)이다.

예: `my_sdk/client.py`
- 모듈 이름: `client`
- import: `import my_sdk.client`, `from my_sdk import client`


2. 패키지(package) 이름이란

패키지는 보통 `__init__.py`를 가진 디렉토리(폴더)이다.

예: 
```
my_sdk/
   __init__.py
   client.py
```
- 패키지 이름: `my_sdk`
- import: `import my_sdk`, `import my_sdk.client`


3. 서브 패키지(subpackage)

패키지 안에 또 패키지가 있으면 서브패키지이다.

예: 
```
src/
  my_sdk/
    __init__.py
    resources/
      __init__.py
      users.py

```
- `resources`는 `my_sdk`의 서브패키지
- import: `import my_sdk.resources`, `from my_sdk.resources import users`

### 빌드 백엔드

파이썬 프로젝트의 소스 트리와 설정(`pyproject.toml`)을 입력으로 받아, 표준 배포물(특히 wheel/sdist)을 만들어 내는 빌드 엔진이다. 
현대 파이썬 패키징(PEP 517/518)에서는 `pip`이나 `python -m build` 같은 도구가 직접 빌드 로직을 갖지 않고, 빌드 백엔드를 호출해서 빌드를 수행하는 구조가 정석이다.

1. 빌드 백엔드가 하는 일(역할)

빌드 백엔드는 크게 다음을 수행한다.

   1. 메타데이터 생성
      - 배포 이름, 버전, 의존성, 파이썬 요구 버전 등(대개 `[project]` 기반)
      - 결과물에 들어갈 `.dist-info` 메타데이터 구성

   2. 패키지/모듈 수집
      -어떤 소스 파일이 배포물에 포함될지 결정
      - `src/` 레이아웃을 어디서 찾을지 적용(설정에 따라)

   3. 배포물 생성
      - `sdist`(소스 배포물) 생성: 보통 `*.tar.gz`
      - `wheel` 생성: `*.whl`

   4. 빌드 훅 제공(PEP 517)
      - front-end(pip/build)가 호출할 표준 인터페이스를 제공


2. 빌드 백엔드 vs 빌드 프론트엔드 (매우 중요)

   - 빌드 프론트엔드(frontend): 빌드를 요청/오케스트레이션하는 도구
      - 예: `pip`, `python -m build`
   - 빌드 백엔드(backend): 실제로 wheel/sdist를 생성하는 엔진
      - 예: `setuptools`, `hatchling`, `flit`, `pdm-backend`

   관계: pip/build는 이 프로젝트를 빌드해줘라고 요청하고, 백엔드는 `pyproject.toml` 설정을 읽어 실제 결과물을 만든다.

3. `pyproject.toml`에서 빌드 백엔드 지정 방식

빌드 백엔드는 `pyproject.toml`의 `[build-system]` 섹션에서 지정한다.

핵심 필드: 
   - `build-backend`: 어떤 백엔드 모듈을 쓸지
   - `requires`: 그 백엔드를 실행하기 위해 필요한 패키지들

예시:
```
[build-system]
requires = ["setuptools>=68", "wheel"]
build-backend = "setuptools.build_meta"
```

이 뜻은: 빌드하려면 setuptools와 wheel이 필요하고, 실제 빌드는 setuptools의 `setuptools.build_meta`가 수행한다는 의미이다.


4. 대표 빌드 백엔드들의 성격

   1. setuptools
      - 가장 오래되고 범용적이며, 레거시 호환이 강하고 커스터마이징 범위가 넓음
      - 대규모/복잡한 패키지에서 여전히 흔함

   2. hatchling
      - Hatch 생태계의 백엔드
      - 설정이 비교적 간결하고, 현대적인 워크플로우에 맞음

   3. flit
      - “순수 파이썬 패키지” 중심으로 단순한 배포에 강점
      - 설정 단순성 강조

   4. pdm-backend
      - PDM 워크플로우와 결합
      - 의존성/빌드 관리가 일관되게 이어지도록 설계

   중요한 결론: 어떤 백엔드를 써도 “wheel/sdist를 만든다”는 목적은 같고,차이는 “설정 방식/자동 탐색 방식/부가 기능/워크플로우”에서 납니다.

### 배포 아티팩트(Build Artifacts)

파이썬 SDK를 배포할 때 생성되는 아티팩트는 크게 두 가지이다.

|아티팩트 종류|주요 특징|역할|
|---|---|---|
|sdist(Source Distribution)|`.tar.gz` 형식의 압축 파일|**원본 소스 코드** 전체를 담고 있다. 어떤 환경에서도 빌드할 수 있는 최소한의 보장이다.|
|wheel(Built Distribution)|`.whl` 형식의 압축 파일|**이미 빌드가 끝난 파일**, 사용자가 `pip install` 할 떄 가장 빠르고 안전하게 설치된다.|

단순히 소스 코드를 깃허브에서 복사해가는 것이 아니라, **아티팩트**를 만들어 배포하는 데는 3가지 핵심 이유가 있다.

   1. 불변성(Immutability)
      한 번 빌드된 아티팩트는 그 버전(`v1.0.0`)의 상태를 그대로 박제한 것이다. 개발자가 나중에 소스 코드를 수정하더라도, 이미 배포된 아티팩트 파일은 변하지 않으므로 사용자는 항상 동일한 코드를 내려받을 수 있다.

   2. 설치 속도와 효율성
      특히 C언어로 된 라이브러리가 포함된 SDK의 경우, 사용자 컴퓨터에서 매번 컴파일하려면 시간이 아주 오래 걸리고 컴파일러 설치도 복잡하다. `wheel` 아티팩트는 이런 빌드 과정을 개발자가 미리 대신 해준것이기에 사용자는 복사만 하면 바로 쓸 수 있다.

   3. 보안 및 검증
      아티팩트 파일에는 체크섬(Hash)값이 부여된다. 사용자는 내가 받은 파일이 개발자가 배포한 그 파일이 맞는지 검증할 수 있어 보안상 안전하다.

      
PyPI 같은 레지스트리에 업로드해서 **클라이언트가 `pip install 패키지명` 명령어로 패키지를 받게 하기 위해서는** 배포 아티팩트(wheel/sdist)로 업로드 해야한다.
즉, 나 혹은 조직이 다른 사람이 `pip install 패키지명`설치할 수 있게 공개/배포하려는 경우 배포 아티팩트(wheel/sdist)를 명시적으로 만들어서 업로드하는 방식이 정석이다.
> 왜냐하면, 레지스트리는 프로젝트 폴더 전체를 올리는 곳이 아니라, 표준화된 배포 포맷(배포물)을 받기 떄문이다.

참고로 로컬 설치/소스 설치(**내가 만든 프로젝트, 남이 만든 프로젝트지만 깃허브 등에서 소스를 직접 가져온 상태**)일 경우 배포 아티팩트(wheel/sdist)를 미리 만들지 않아도 된다.
이 경우

- `pip install .`
- `pip install -e .`
- `pip install git+https://...`

와 같은 명령어로 설치를 하게 된다. 다만, 여기서 꼭 명심해야 할 포인트는 미리 만들지 않아도 되는거지 배포 아티팩트(wheel/sdist)가 전혀 안 만들어지는 것이 아니다. 
pip은 설치 과정에서 내부적으로 wheel을 임시로 빌드해서 설치할 수 있다. 

### `src/` 레이아웃 

1. 전형적인 `src/` 레이아웃 구조

```
my-sdk/                     # 프로젝트 루트
  pyproject.toml
  README.md
  src/                      # 소스 루트(source root)
    my_sdk/                 # import 패키지 이름(my_sdk)
      __init__.py
      client.py
  tests/
    test_client.py
```

여기서 핵심은 프로젝트 루트와 파이썬 패키지 루트를 분리한다는 점이다.


2. 왜 굳이 `src/`로 분리하나?

   1. 설치 없이도 import 되는 착시 방지
      플랫 레이아웃(루트에 패키지가 바로 있는 구조)은 종종 이런 문제가 생긴다. 
         - 프로젝트 루트가 파이썬의 탐색 경로(`sys.path`)에 들어가서 `pip install`을 안했는데도 `import my_sdk`가 되는 것처럼 보임

      그러면
         - 배포에 필요한 파일 누락
         - 패키지 포함 설정 오류
         - 상대 경로/리소스 로딩 문제

      같은 문제를 놓치기 쉽다.

      `src/` 레이아웃은 루트에 패키지가 없고 `src/`아래에만 있으니, 설치(또는 editable 설치)하지 않으면 기본적으로 `import my_sdk`가 실패한다. 

      즉, 설치된 상태에서만 동작하도록 강제해서 패키징 오류를 초기에 잡는다.

   2. 테스트가 설치된 패키지를 대상으로 돌아가게 유도
      SDK는 결국 사용자가 설치해서 쓰는 게 목적이므로, 테스트도 설치된 패키지를 기준으로 도는 게 더 안전하다.
      `src/` 레이아웃은 이 방향과 잘 맞다.

   3. 패키지/프로젝트 경계가 명확해짐
      - 프로젝트 루트: 문서/설정/테스트/CI
      - `src/`: 배포될 코드

      경계가 분명해져 유지보수에 유리하다.

### `__init__.py`

`__init__.py`는 파이썬 패키지에서 **이 디렉토리는 패키지다.**를 명확히 하고, 그 패키지가 `import`될 때 실행되는 초기화 코드와 외부에 노출할 API(공개 표면)를 정의하는 핵심 파일이다.

1. 언어(import) 관점: `__init__.py`가 있는 폴더 = (전통적) 패키지 단위

전통적인 regular package 규칙에서 `pro1/pkg/__init__.py`가 있으면 파이썬은 `pkg`를 패키지로 인식한다. 따라서 이 경우 `pro1/main.py`에서 `import pkg`를 사용할 수 있다.
`pro1/pkg/sub/__init__.py`가 있으면 `pro1/main.py`에서 `import pkg.sub`를 사용할 수 있다.
> 이는 파이썬 언어(import 시스템)의 규칙이다. / 모듈과 패키지의 개념 명심하기

이때 `import pkg`는 단순히 폴더를 불러온다가 아니라 일반적으로 

- `pkg` 디렉토리를 찾고, `pkg/__init__.py`를 로드하고 실행하여 패키지 객체 `pkg`의 네임스페이스를 구성하는 것이다. 

따라서, `__init__.py`는 패키지 초기화 코드의 실행 지점이기도 하다.
> 예외(고급): Python 3.3+의 네임스페이스 패키지는 `__init__.py` 없이도 패키지가 될 수 있다. 다만 SDK/일반 라이브러리에서는 의도적 설계가 아니라면, 보통 regural package(`__init__.py` 포함)를 쓴다.


2. 빌드/패키징 관점

빌드 도구들도 대부분의 경우 `__init__.py`가 있는 디렉토리를 패키지 단위로 본다. 이는 파이썬 언어의 관점을 차용하는 것처럼 보인다.

하지만 둘은 매우 중요한 분리가 있다.

- 파이썬 언어(import)는 무엇이 패키지인가를 런타임에 결정한다.
- 빌드 도구는 무엇을 배포물(wheel/sdist)에 포함할 것인가를 빌드 타임에 결정한다.

2-1. 빌드 도구가 하는 일

빌드 도구(setuptools/hatching/flit/pdm-backend 등)는 빌드 시점에
   1. 소스 트리에서 "패키지/모듈로 배포할 대상"을 찾고
   2. 그것들을 wheel/sdist에 포함시키는 규칙을 적용한다.

2-2. 빌드 도구들이 언어 관점을 차용하는 것처럼 보이는가?

많은 빌드 설정/관례(특히 setuptools의 전통적 자동 탐색 패턴)는 다음 논리를 사용해 왔다.
   
   - 파이썬의 regular package는 `__init__.py`로 표시된다.
   - 따라서, `__init__.py`가 있는 폴더들을 패키지로 수집하자!

그래서 실무에서 흔히 `pro1/pkg/__init__.py`가 있는 폴더가 **빌드에 포함되는 패키지**가 되고 그 결과로 `wheel/sdist`에 들어가서 설치 후 `import pkg`가 된다는 흐름이 자연스럽게 이어진다.

2-3. 엄밀한 단서(매우 중요)

다만 이것은 언어 규칙을 빌드 도구가 그대로 강제한다가 아니라, **빌드 도구의 패키지 탐색/포함 전략이 regular package 관례에 맞춰져 있는 경우가 많다**는 뜻이다.
백엔드/설정에 따라 명시적으로 지정할 수도 있고, 네임스페이스 패키지(`__init__.py`가 없음)를 포함하는 방식도 있을 수 있다.
따라서, 항상 `__init__.py`가 있어야만 빌드에 포함된다는 절대 규칙은 아니다.

> 언어 관점에서 `__init__.py`는 regular package의 신호다. 빌드/패키징 관점에서 많은 도구/관례는 그 신호를 **패키지 탐색 힌트**로 활용한다. 그러나 최좀 포함 여부는 빌드 백엔드의 설정/정책이 결정한다.

3. `__init__.py`의 역할: **필수 역할**과 **선택적 역할**

3-1. 필수 역할(regular package 기준에서의 핵심 의미)

   1. 패키지 경계 표시
      이 폴더를 regular package로 만들고(import 가능하게 하고), 서브 패키지 구졸르 명확히 한다.

   2. 패키지 초기화 코드 실행 지점
      `import pkg`시 실행되는 코드가 들어갈 수 있다.(비어 있어도 됨)

3-2. 선택적 역할(실무 SDK에서 매우 흔함)

   1. 공개 API 재노출(re-export)
      사용자가 내부 모듈 경로를 몰라도 되게 `from my_sdk import Client, ApiError` 같은 형태를 제공하기 위해 `__init__.py`에서 심볼을 가져와 노출한다.

   2. `__all__`로 공개 표면을 명시
      이 패키지가 공식적으로 노출하는 것을 선언(필수는 아님)

   3. 버전/상수 제공
      `__version__`같은 메타 정보 제공(관리 방식에 따라 선택)


#### 2. 전체적인 흐름 설명



---

## SDK 만들기 실습