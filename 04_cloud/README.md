# 04. 클라우드에 API 배포하기

클라우드 API 배포란 API 서버(HTTP/REST/GraphQL 등)를 물리 서버가 아닌 클라우드 인프라 상에서 실행·공개·운영하는 것을 의미한다.
여기서 핵심은 단순히 인터넷에 띄우는 것이 아닌 클라우드 제공하는 인프라 추상화와 자동·확장·고가용성·보안·관측성을 API 운영의 기본 전제로 삼는다는 것이다.

즉, API는 코드이지만 배포 이후의 생명주기 전체를 클라우드가 관리한다.

---

## 클라우드 배포의 장점과 책임

장점

- 프로젝트를 통해 클라우드 개발, 배포, 운영의 전 과정을 체험할 수 있다.
- 프로젝트 포트폴리오로 활용하면서 다른 사람들과 공유할 수 있고, 이를 통해 빠른 피드백을 받아 지속적으로 개선할 수 있다.
- 외부에 API를 배포함으로써 사용자 관점에서 실제 인터넷 환경에서 동작하는 도구나 서비스를 테스트할 수 있다.
- 생성형 AI 서비스와 연계해 API를 활용할 수 있다.


책임

- 비용: 대부분의 클라우드 서비스는 사용량에 따라 과금을 하며, 무료 요금제나 시작 크레딧이 제공되는 경우에도 계정 생성시 신용카드나 체크카드를 등록해야 한다. 

- 실제로 클라우드 호스트에서 프로젝트를 개발하다 보면 월말에 몇 달러 정도의 예상치 못한 비용이 종종 발생하고, 관리가 느슨하면 수백~수천 달러로 불어나는 경우도 적지 않다.

- 보안에 대한 책임: API 엔드포인트를 외부에 노출한다는 표현 자체가 위험성을 내포하고 있다. 클라우드 서비스에 접근하는 데 사용하는 인증 정보(예: 사용자 이름, 비밀번호, API 키 등)를 부주의하게 다룰 경우, 해당 정보 외부에 노출될 수 있으며, 이는 심각한 보안 사고로 이어질 수 있다.



클라우드 서비스를 사용할 때 예상치 못한 과금을 방지하려면 아래와 같은 비용 관리 수칙을 지켜야 한다.

- 서비스를 사용하기 전에 각 항목의 비용을 꼼꼼히 확인하고, 가능하다면 비용 계산기를 활용해 예산을 산정한다.

- 무료 요금제 또는 무료 체험 기간이 제공되는 서비스를 우선 활용한다.

- 월간 예산을 사전에 설정하고, 예산 한도에 도달하기 전 이메일 알림을 받을 수 있도록 알림 기능을 설정한다.

- 사용이 끝난 리소스는 반드시 중지하거나 삭제해 불필요한 요금 발생을 방지한다.

- 클라우드 호스트에서 작업이 끝난 후에는 사용한 리소스를 정리하고, 결제 수단도 제거하는 것이 좋다.

- 인증 정보는 외부에 유출되지 않도록 철저히 관리해야 하며, 단기 액세스 키를 사용하는 것이 바람직하다.

- 필요한 권한만 최소한으로 부여하고, 작업이 끝나면 불필요한 권한은 즉시 비활성한다.

- 소스 코드 저장소(Git 등)에 인증 정보를 절대 커밋하지 않는다.

- 만약 인증 정보가 외부에 노출됐다면, 즉시 해당 계정을 비활성화하거나 삭제하고, 필요 시 클라우드 제공업체의 지원팀에 문의해 조치를 취해야 한다.

---

## 클라우드와 클라우드 호스트


현대 정보 기술(IT) 인프라 환경에서 클라우드(Cloud)라는 용어는 광범위하게 사용되고 있다.
인터넷 기술의 발전은 데이터 저장과 처리 방식을 로컬 하드웨어에서 네트워크 기반의 원격 서버로 이동시켰다. 이 과정에서 등장한 클라우드라는 은유는 기술적 세부 사항을 추상화하여 사용자의 편의를 높였지만, 역설적으로 기술의 실체를 파악하는 데 장벽이 되고 있다. 
특히 웹 호스팅, 가상 사설 서버(VPS), 클라우드 컴퓨팅, 클라우드 호스트 등의 용어가 혼재되어 사용되면서 소비자는 서비스의 본질적인 차이와 비용 구조, 관리 책임을 명확히 인지하지 못한 채 서비스를 선택하는 경향이 있다.

클라우드(AWS/Azure/GCP)는 하나의 플랫폼(서비스 생태계)이고, 클라우드 선택은 어느 플랫폼을 사용할지 결정하는 것이다. 
그 다음 단계로, 해당 플랫폼 안에서 애플리케이션/API 을(를) 실행시키는  호스팅 방식(예: VM/PaaS/컨테이너/서버리스)을 고르고, 그 방식에 해당하는 구체 서비스를 선택하는 것이 클라우드 호스팅(클라우스 호스트 선택)이다.
각 클라우드는 비슷한 호스팅 모델을 제공하지만, 네트워크/IAM/배포·관측/비용/통합성 같은 디테일에서 차이가 커서 목적에 따라 최적 선택이 달라진다.
> 클라우드 호스트는 호스팅을 하는 곳(서비스/환경)이고, 호스팅은 그곳에 올려 운영하는 행위이다.

---

### 클라우드(Cloud)는 무엇인가?

클라우드는 다음을 동시에 의미한다.

1. 컴퓨팅 제공 모델(방식)

- 서버·스토리지·네트워크 같은 자원을 필요할 때 즉시(on-demand) 빌려 쓰고 수요에 맞게 탄력적으로 확장/축소하며 사용량을 측정하여 과금하는 방식

2. 서비스 생태계(플랫폼)

- 모델을 구현하기 위해 데이터센터, 가상화, 네트워크, 보안, 관측, 운영 자동화까지 포함한 거대한 플랫폼이다. 
- 실무에서 클라우드라고 부를 떄는 보통 AWS/Azure/GCP 같은 제공자를 의미한다.


클라우드의 본질은 하나의 기술이나 범주가 아닌 아래의 5개 성질의 결합이다.

- 온디맨드 셀프 서비스: 콘솔/CLI/API로 자원을 즉시 생성/삭제
- 광범위한 네트워크 접근: 인터넷/전용망으로 어디서든 접근
- 자원 풀링(멀티테넌시): 물리 자원을 풀로 묶어 논리적으로 분배
- 신속한 탄력성: 트래픽 변화에 빠르게 대응(오토스케일)
- 측정 서비스(과금/최적화): 사용량을 계량해 비용·최적화가 가능

클라우드는 아래의 구성요소(4대 자원 + 제어면)들이 결합된 결과물이다.

1. 4대 핵심 자원

- Compute: CPU/RAM/GPU 등 연산 자원(VM/컨테이너/함수 형태로 제공)
- Storage: 블록/오브젝트/파일 스토리지로 분리되어 제공(풀 기반)
- Network: VPC/VNet, 서브넷, 라우팅, 방화벽, 로드밸런서 등
- Virtalization/Abstraction: VM 가상화(하이퍼바이저), 컨테이너 격리, 네트워크/스토리지 가상화

2. 제어면(Control Plane)

클릭 몇 번으로 VM 생성이 가능한 이유는 뒤에서 제어면이 다음을 자동으로 수행하기 떄문이다.

- 프로비저닝(자원 할당), 구성, 상태 관리
- 장애 감지/복구(헬스체크, 재시작)
- 스케일링 정책 적용
- 권한(IAM) 적용, 로그/모니터링 연동

---

### 클라우드 호스트는 무엇인가?

클라우드 호스트는 클라우드 환경에서 애플리케이션(API/웹앱)이 실행되고, 외부에서 접속 가능하게 노출되며, 배포·확장·복구·관측 같은 운영 기능까지 포함해 서비스가 돌아가도록 해주는 **호스팅 실행 환경(서비스/방식)**이다.

여기서 핵심은 두 가지이다.

1. **실행 환경**: 코드가 돌아가는 컴퓨팅 기반(프로세스/컨테이너/함수/VM)

2. **운영까지 포함**: 단순 실행이 아니라 스케일, 재시작, 헬스체크, 로그 등 운영 기능을 동반

클라우드 호소트가 단순히 서버를 빌려주는 것 이상의 의미를 가지는 이유는 아래의 3가지 기능들이 결합되기 떄문이다.

1. 실행(Compute): API/웹앱 코드가 CPU·메모리(필요 시 GPU) 자원 위에서 프로세스·컨테이너·함수 형태로 실제 동작하도록 만드는 기능을 의미하며, 런타임 제공, 자원 할당/제한, 동시성 처리, 인스턴스 생성·종료 같은 실행 모델이 포함된다.

2. 노출(Serving/Ingress): 외부 사용자의 요청이 애플리케이션까지 도달할 수 있도록 접속 경로를 구성하는 기능으로, URL/포트 제공, HTTPS(TLS) 적용, 도메인 연결, 라우팅과 로드밸런싱, 방화벽·접근제어 같은 네트워크 보안 경계 설정이 포함되며, 경우에 따라 API Gateway나 WAF 같은 진입 계층과 결합된다.

3. 운영(Operations): 배포 이후 서비스를 안정적으로 유지하기 위한 기능으로, 헬스체크 기반의 장애 감지, 자동 재시작 및 자가 복구, 오토스케일, 무중단 배포와 롤백(버전/리비전 관리), 로그·메트릭·알림 연동 같은 관측성과 운영 자동화를 포함한다

> 즉, 클라우드 호스트는 **실행 + 노출 + 운영**의 묶음으로 이해하는 것이 정확하다.

---

### 전통적 인프라에서의 호스트와 클라우드 호스트의 차이

클라우드 호스트라는 말은 원래 IT 용어의 호스트 머신(무언가가 올라가서 실행되는 기반)에서 출발했지만, 클라우드 배포 문맥에서는 의미가 더 넓어져서 보통 다음을 통칭한다.
> **API(또는 애플리케이션)가 실행될 수 있도록 컴퓨팅·네트워크·운영 기능을 제공하고, 외부(또는 내부)에서 접속 가능한 형태로 서비스를 노출해 주는 설행/호스팅 플랫폼**

1. 전통 인프라에서 host의 원래 의미

전통 인프라/네트워크/시스템 관점에서 호스트는 보통 네트워크에 연결된 엔드포인트이자, 서비스를 실행하는 단일 머신(물리 서버 또는 VM/노드)를 의미한다.

즉, 호스트는 한대의 컴퓨터(실행 주체)라는 의미가 강했다.

2. 클라우드에서의 host의 의미

클라우드/배포 문맥에서의 호스트는 대개 머신 대부분 머신 1대가 아니라, 애플리케이션을 올려서 운영할 수 있게 해주는 관리형 실행 환경(플랫폼/서비스)를 뜻한다.


클라우드에서도 host를 두 레벨로 구분하면 가장 정확하다.

1. Host machine(호스트 머신): 실제로 코드가 돌아가는 VM/노드

- PaaS/서버리스에서도 실제로는 존재하지만 사용자에게 숨겨짐

2. Hosting service/platform(호스팅 서비스/플랫폼): App Service, Cloud Run 같은 관리형 실행 서비스

- 실무 대화에서 “호스트”라고 부르는 대상이 종종 이것을 의미한다.

---

## 클라우드 호스트 선택 방법

클라우드 호스트는 단순히 “서버를 어디서 돌릴지”를 정하는 문제가 아니라, **운영 책임(어디까지 직접 관리할지)**과 비용 구조(어디서 비용이 발생할지), 그리고 배포·확장·복구·관측 같은 운영 역량을 어떤 수준으로 확보할지를 동시에 결정하는 문제다. 특히 클라우드는 VM, PaaS, 관리형 컨테이너, 서버리스 등 호스팅 모델이 다양하며, 각 모델은 추상화 수준이 다르기 때문에 사용자가 부담해야 하는 작업(예: OS 패치, 런타임 관리, 오토스케일 구성, 네트워크 설계)의 범위가 크게 달라진다. 따라서 “유명한 회사”나 “남들이 많이 쓰는 서비스”만으로 선택하면, 실제 목적(예: 빠른 배포, 인프라 학습, 운영 자동화 실습, 비용 통제)과 맞지 않아 개발 속도나 운영 안정성, 비용 효율 측면에서 불리해질 수 있다.

또한 클라우드의 기능과 요금 모델은 시간이 지나며 변동되므로, 한 번 선택한 뒤에도 지속적으로 운영해야 한다는 관점에서 변경 가능성(Portability)과 잠금 효과(Vendor lock-in) 정도를 함께 고려해야 한다. 예를 들어 특정 PaaS의 배포 방식에 깊게 의존하면 초기 생산성은 높아질 수 있지만, 장기적으로 다른 환경으로 옮기기 어려워질 수 있다. 반대로 컨테이너 기반 호스팅은 표준화된 배포 단위를 사용하므로 이식성이 높아지는 대신, 이미지 빌드·레지스트리·배포 파이프라인 등 운영 요소를 더 체계적으로 구성해야 한다. 결국 “호스트 선택”은 단기 편의성과 장기 운영/학습 목표 사이에서의 최적 균형을 찾는 과정이며, 이를 위해서는 먼저 목적을 구체화한 뒤 그 목적에 맞는 호스팅 모델과 서비스를 단계적으로 고르는 접근이 가장 합리적이다.

1. 신속한 배포와 개발 생산성이 최우선인 경우

개발 단계에서 빠르게 배포하고 URL로 즉시 공유하는 것이 중요하다면, 인프라 설계 부담이 낮고 배포 흐름이 단순한 호스트가 적합하다. 이 경우에는 PaaS 또는 **서버리스 컨테이너(관리형 컨테이너)**가 유리하다. 운영 측면(HTTPS, 스케일, 헬스체크, 기본 모니터링)이 기본 제공되는 경우가 많아, 사용자는 코드와 환경 설정에 집중할 수 있다.

- 추천 모델: PaaS / 서버리스 컨테이너
- 기대 효과: 빠른 출시, 운영 부담 최소화
- 주의점: 플랫폼 제약(네트워크/런타임/커스터마이징) 및 잠금 효과 가능

2. 특정 클라우드 플랫폼(AWS/Azure/GCP)의 핵심 인프라를 학습하는 것이 목적일 경우

네트워크(VPC/VNet), 보안(IAM), 로드밸런싱, 스토리지/디스크, 시스템 운영(OS/패치)까지 폭넓게 이해하려면, 추상화가 높은 서비스보다 VM(IaaS) 또는 **Kubernetes(관리형 K8s)**처럼 인프라 구성 요소가 드러나는 환경이 학습 효과가 크다. 즉 “불편함”이 학습의 재료가 된다.

- 추천 모델: VM(IaaS) / (심화) 관리형 Kubernetes
- 기대 효과: 인프라 설계·운영 역량 확보, 클라우드 핵심 개념 체득
- 주의점: 초기 설정 복잡, 운영 부담 증가, 실수 시 비용/보안 리스크

3. CI/CD와 컨테이너 기반 배포(Containerization) 운영 루프를 연습하려는 경우

빌드–테스트–이미지 생성–레지스트리 푸시–배포–롤백까지 “배포 파이프라인 전체”를 연습하려면, 배포 단위가 표준화된 컨테이너 기반 호스팅이 가장 적합하다. 특히 관리형 컨테이너 환경은 인프라 운영 부담을 줄이면서도 컨테이너·레지스트리·배포 전략을 실습하기 좋아 균형이 좋다.

- 추천 모델: 관리형 컨테이너(서버리스 컨테이너) / (심화) Kubernetes
- 기대 효과: 표준 배포 단위(Docker) 기반 운영 역량, 롤백/버전관리 실습
- 주의점: 이미지 최적화, 환경변수/비밀관리, 네트워크/권한 설계 필요

4. 비용 효율과 예측 가능한 과금이 최우선인 경우

비용을 최우선으로 두면 “어떤 모델이 항상 싸다”라고 단정할 수는 없지만, 일반적으로 항상 켜져 있는 워크로드는 VM/고정 리소스가 유리해질 수 있고, 간헐적·스파이크형 트래픽은 서버리스(함수/컨테이너)가 유리해질 수 있다. 또한 클라우드는 호스트 비용 외에 로드밸런서, 로그 저장, 외부 트래픽(egress)에서 비용이 커지므로, 비용 목적이라면 호스팅 모델과 함께 부가 비용 구조를 같이 고려해야 한다.

추천 모델(경향):
- 지속 트래픽/상시 운영: VM(IaaS) 또는 예약/고정형 호스팅
- 간헐 트래픽/이벤트성: 서버리스(FaaS) / 서버리스 컨테이너
- 주의점: 로그/모니터링/네트워크 egress가 비용을 좌우할 수 있음

5. 운영 안정성(가용성)과 장애 대응이 최우선인 경우

서비스를 실제 사용자에게 제공하거나, 장애 시 영향이 큰 경우에는 “운영 기능이 얼마나 성숙하게 제공되는지”가 중요하다. 이 목적에서는 헬스체크 기반 복구, 오토스케일, 무중단 배포/롤백, 모니터링·알림의 기본 제공 수준을 중점적으로 보게 되며, 대체로 PaaS/관리형 컨테이너가 운영 기능을 일관되게 제공하는 경우가 많다. 다만 복잡한 트래픽 제어/정교한 네트워크가 필요하면 Kubernetes 같은 선택이 필요해질 수 있다.

- 추천 모델: PaaS / 관리형 컨테이너 / (규모·복잡도 증가 시) Kubernetes
- 기대 효과: 운영 자동화, 장애 복구 체계 강화
- 주의점: 고급 요구(사설망/복잡한 라우팅)에서는 설계 난이도 상승

--- 

## ngrok 배포와 클라우드 배포

ngrok (집으로 친구 초대하기)

ngrok은 로컬(또는 사설망)에서 실행 중인 서버로 트래픽이 들어오도록 공개 엔드포인트를 만들고, 그 트래픽을 ngrok agent가 upstream(내 앱)으로 전달하는 구조이다.

- API는 여전히 내 노트북/PC 또는 사설망 서버에서 실행된다.

- ngrok은 공개 URL(HTTPS 포함)을 만들어서 외부 요청이 들어오게 하고, 그 요청을 내 로컬로 터널로 전달한다.

즉, ngrok은 로컬에서 작동중인 서비스에 다른 사용자가 접속을 가능하게 해주는 것이다.


클라우드 배포 (전문 식당에 내 레시피를 전달하기)

클라우드 배포는 API 자체를 클라우드의 실행 환경(IaaS/PaaS/컨테이너/서버리스)에 올려서, 그 환경에서 24/7 운영 가능하게 만드는 것이다.

- 내 API 실행 위치: 클라우드 인프라/관리형 플랫폼

- 확장/복구/관측(로그·메트릭) 등 운영 기능이 클라우드 서비스로 통합된느 경우다 많다.

- 일반적으로 프로덕션 운영(가용성, 확장성, 보안, 비용 관리)에 맞춰 설계한다.

---

## Azure 클라우드를 이용한 API 배포

### 1. 도커 이미지 생성하기

터미널에 아래의 명령어를 입력한다.

`docker build -t apicontainerimage .`

이 명령어는 현재 디렉토리에 있는 도커파일을 참조해 apicontainerimage라는 이름의 이미지를 빌드한다.
빌드된 이미지는 로컬 도커 저장소에 저장되는데, 처음 실행할 때에는 필요한 베이스 이미지와 의존 패키지를 다운로드하느라 시간이 걸릴 수 있지만 이후부터는 변경되지 않은 항목이 캐시되기에 훨씬 빠르게 빌드된다.

작업이 완료되면 다음과 같은 형식의 실행 결과가 표시된다.

```
[+] Building 19.1s (11/11) FINISHED                                                                                             docker:desktop-linux 
 => [internal] load build definition from Dockerfile                                                                                            0.0s 
 => => transferring dockerfile: 664B                                                                                                            0.0s 
 => [internal] load metadata for docker.io/library/python:3.12-slim                                                                             1.7s 
 => [internal] load .dockerignore                                                                                                               0.0s 
 => => transferring context: 96B                                                                                                                0.0s 
 => [1/6] FROM docker.io/library/python:3.12-slim@sha256:5e2dbd4bbdd9c0e67412aea9463906f74a22c60f89eb7b5bbb7d45b66a2b68a6                       5.6s 
 => => resolve docker.io/library/python:3.12-slim@sha256:5e2dbd4bbdd9c0e67412aea9463906f74a22c60f89eb7b5bbb7d45b66a2b68a6                       0.0s 
 => => sha256:5e2dbd4bbdd9c0e67412aea9463906f74a22c60f89eb7b5bbb7d45b66a2b68a6 10.37kB / 10.37kB                                                0.0s 
 => => sha256:ef24548e6db34726360ab68d85d8054197c409650aa1796dd2694fcbb1e8d633 1.75kB / 1.75kB                                                  0.0s 
 => => sha256:c78a70d7588fc2f2a6d4a9777b09c4a1a22beb89586a8de86532be0c8e9eb20f 5.68kB / 5.68kB                                                  0.0s 
 => => sha256:119d43eec815e5f9a47da3a7d59454581b1e204b0c34db86f171b7ceb3336533 29.77MB / 29.77MB                                                3.7s 
 => => sha256:83e2eb8c4c73235e21df3ea0ce6aa840fcb84f4cb368fb6b443a8a87d95850d0 1.29MB / 1.29MB                                                  1.2s 
 => => sha256:671677b67e7671119d142c2f8548882641edfad92863ee1ccff2cd84c3b14a2a 12.11MB / 12.11MB                                                3.0s 
 => => sha256:3d6ef8a4ce0aaaaa35261feb115464317fcb4910873cba90171f7ad544a9964e 249B / 249B                                                      1.8s 
 => => extracting sha256:119d43eec815e5f9a47da3a7d59454581b1e204b0c34db86f171b7ceb3336533                                                       0.9s 
 => => extracting sha256:83e2eb8c4c73235e21df3ea0ce6aa840fcb84f4cb368fb6b443a8a87d95850d0                                                       0.1s 
 => => extracting sha256:671677b67e7671119d142c2f8548882641edfad92863ee1ccff2cd84c3b14a2a                                                       0.5s 
 => => extracting sha256:3d6ef8a4ce0aaaaa35261feb115464317fcb4910873cba90171f7ad544a9964e                                                       0.0s 
 => [internal] load build context                                                                                                               0.1s 
 => => transferring context: 635.00kB                                                                                                           0.1s 
 => [2/6] WORKDIR /code                                                                                                                         0.1s 
 => [3/6] COPY src/requirements.txt /code/                                                                                                      0.1s 
 => [4/6] RUN pip3 install --no-cache-dir --upgrade -r requirements.txt                                                                        11.1s 
 => [5/6] COPY src/*.py /code/                                                                                                                  0.1s 
 => [6/6] COPY src/*.db /code/                                                                                                                  0.1s 
 => exporting to image                                                                                                                          0.6s 
 => => exporting layers                                                                                                                         0.6s 
 => => writing image sha256:ebbc965aefa2201b5a9a65602417f8ce481f8913c157dbec2c195951024e440c                                                    0.0s
 => => naming to docker.io/library/apicontainerimage                                                                                            0.0s

View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/mngw3r42vlo6w62zsgypjb7yt

What's next:
    View a summary of image vulnerabilities and recommendations → docker scout quickview 
```

위의 결과가 나왔다면 이미지는 성공적으로 생성된 것이다. 
이미지 생성 성공 여부를 터미널에서 확인하고 싶다면


`docker images | findstr apicontainerimage`

해당 명령어를 입력하고 아래의 출력결과가 있다면 성공적으로 생성된 것임을 확인할 수 있다.

`apicontainerimage         latest    ebbc965aefa2   4 minutes ago   222MB`


### 2. 로컬에서 컨테이너 이미지 실행하기

앞에서 생성한 도커 이미지를 기반으로 컨테이너를 실행하려면 다음과 같은 명령어를 입력한다.

`docker run --publish 80:80 --name apicontainer1 apicontainerimage`

명령어를 실행하면 아래와 같은 메세지가 출력된다.

```
INFO:     Started server process [1]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:80 (Press CTRL+C to quit)
```

이제 브라우저에서 `localhost`에 접속하면 성공적으로 API가 활성화 됐음을 확인할 수 있다.
여기까지 되었다면, API가 도커 컨테이너에서 정상적으로 실행되고 있는 것이다. 실행을 중지하려면 `Ctrl + C`를 누른다.


### 3. Azure Container Registry에 로컬의 컨테이너 올리기

Azure에서 컨테이너 기반으로 클라우드상에서 API를 실행시키려면 먼져 **"이미지 아티팩트**가 Azure에서 접근 가능해야 한다.

Azure App Service나 Azure Container Apps, Azure Virtual Machine 같은 클라우드 호스트는 기본적으로 내 로컬 PC 디스크에 있는 이미지에 접근하지 않는다. 
클라우드 호스트는 레지스트리(대표적으로 Azure Container Registries, ACR)에서 이미지를 가져오는 구조이다. 그래서 보통 컨테이너 기반으로 클라우드를 활용하여 배포할 때의 첫 단계는 이미지를 ACR에 푸시하는 것이다.

- 먼져 Azure에 로그인하고 **Container registries** 카테고리로 들어가고 **create**를 누른다.

- **Resource Group**과 **Registry name**을 입력하고 **Review + create**를 누르고 검증이 끝나면 **create**를 누른다.

이제 컨테이너의 이미지가 들어갈 창고 하나가 만들어진거고, 이미지는 아직 올라가지 않은 상태이다.
여기까지 했다면 `az cli` 를 활용하여 로컬의 컨테이너 이미지를 `Azure Container registries`에 올려야한다.

- 터미널에 `az login`을 하여 로그인을 한다. 그 다음 `az acr list --output table` 를 입력하여 위에서 만든 저장소가 정상적으로 만들어졌는지 확인한다.

- 터미널에 `az acr login --name {생성한 ACR 저장소 이름}`을 입력하여 Docker에 이전 단계에서 생성한 ACR 저장소에 접근해도 된다는 인증 자격을 준다.

- Azure에 올릴 컨테이너 이미지에 태그를 달아야 하므로 `docker tag {생성한 ACR 저장소 이름}:latest {생성한 ACR 저장소 이름}.azurecr.io/{컨테이너 이름}:latest`
> Docker는 태그 없이는 목적지와 버전을 구분할 수 없기에 태그를 달아야 한다.

- 이제 `docker push hsapicontainer1.azurecr.io/apicontainerimage:latest` 명령어를 입력하여 ACR에 컨테이너 이미지를 push한다.

push에 성공하였다면 아래와 같은 결과가 나온다.


```
The push refers to repository [hsapicontainer1.azurecr.io/apicontainerimage]
56c3336211c0: Pushed 
c830f4211b5d: Pushed
aedb57ed0096: Pushed
ab2e5da72dd0: Pushed
91c94f28f012: Pushed
343fbb74dfa7: Pushed
cfdc6d123592: Pushed
ff565e4de379: Pushed
e50a58335e13: Pushed
latest: digest: sha256:17bac3ff08b8f2d4ece4c0c245e1a34ec10ebdc98505483935cdcc11242a3835 size: 2202
```

- 터미널에 `az acr repository list --name {생성한 ACR 저장소 이름} --output table`을 입력하였을 때

```
Result
-----------------
{컨테이너 이미지 이름}
```

- 혹은 터미널에 `docker pull {생성한 ACR 저장소 이름}.azurecr.io/{컨테이너 이미지 이름}:latest`

위의 결과가 나오면 ACR에 정상적으로 올라갔음을 알 수 있다.

### 4. API 배포하기

이미지가 준비되면, 그 다음이 진짜 의미의 클라우드 호스트 선택(실행 환경 선택)이다.

여기서 후보는 대표적으로 

- App Service(Custom Container): PaaS 성격, 빠르고 단순
- Container Apps: 서버리스 컨테이너, 컨테이너 운영 루프에 더 자연스러움
- Container Instance(ACI): 매우 단순한 단일 컨테이너 실행(주로 배치/테스트/일회성)
- VM: 가장 낮은 추상화(직접 운영), 학습·통제는 크지만 부담도 큼
- AKS: 쿠버네티스(규모/복잡도 있을 때)

여기서는 **App Services**로 API를 배포한다.

`App Services` 접속하여 **리소스 그룹**과 **Web App Name**을 적당한 입력하고, **Publish**항목을 반드시 **Container**로 바꿔준다.

- 작성을 완료하였다면 스크롤을 아래로 내려서 **Review + create**를 누른다.

- 검증이 끝났다면 이제 **create**를 누른다.

- 생성이 완료되었다면 **Go to resource**를 누른다.

- 왼쪽의 작업 테이블에서 **Deployment** -> **Deployment Center**를 선택

- **name** 카테고리의 **main** 선택
> 이는 main이라는 임시 컨테이너를 다른 이미지로 교체하는 것이다.

- **Image Source**를 **Azure Contaier Registry**로 교체하고 **Registry**를 이전 단계에서 생성한 저장소 이름으로 변경한다.

- 그 다음 Image이름과 태그를 작성하고 포트를 8000으로 바꾸고 **Apply**를 누른다.

- 이후, 이전 단계에서 생성한 ACR로 가서, **Add role assignment**항목으로 간 후 **AcrPull**을 누르고 **Next**를 누른다.

- **Managed identity**를 누르고 **Select members**를 눌러서 이전에 생성한 App Service 호스트를 선택한다.

- 이제 도메인을 가지고 접속하면 된다.

해당 도메인으로 웹 상에서 접속이 되었다면 Azure 클라우드를 사용하여 API 배포를 성공한 것이다.